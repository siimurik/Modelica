#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Tutorial.Mechanics.MultiBody.Examples.SpringMass_MSL
 Dymola Version 2023x, 2022-10-07 translated this at Tue Apr  4 18:43:34 2023

   */

#include <matrixop.h>
#include "matrixop.c"
#if defined(DynSimStruct)
static double DymArrays0[3]={3.0, 3.0, 0.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    4
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    25
#define NWP_   9
#define NP_    11
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -225563737
#define NHash2_ 1294540484
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    19
#define SizePre_ 0
#define SizeEq_ 2
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Tutorial.Mechanics.MultiBody.Examples.SpringMass_MSL";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/karlv/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
InitialSection
#if defined(DynSimStruct)
DYNX(W_,20) = 0;
DYNX(W_,21) = 0;
DYNX(W_,23) = 0;
DYNX(W_,24) = 0;
DYNX(F_,1) = 0;
#endif

InitialSection
#if defined(DynSimStruct)
DYNX(W_,0) = 4;
DYNX(W_,1) = 0.0001;
DYNX(W_,2) = false;
DYNX(W_,3) = 4;
DYNX(W_,4) = 0.0001;
DYNX(W_,5) = false;
memcpy(&DYNX(W_,6), &DymArrays0, sizeof(double)*3);
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,18) = DYNX(DP_,4)*(DYNX(X_,2)-DYNX(DP_,6));
DYNX(W_,19) = DYNX(DP_,5)*DYNX(X_,3);
DYNX(W_,14) = DYNX(W_,18)+DYNX(W_,19);
 /* Linear system of equations to solve. */
DYNX(W_,24) = RememberSimple_(DYNX(W_,24), 0);
SolveScalarLinearParametric(DYNX(DP_,9),"mass2.m",  -DYNX(W_,14),
  "mass2.flange_a.f", DYNX(W_,24),"der(mass2.v)");
 /* End of Equation Block */ 

DYNX(W_,12) = DYNX(DP_,1)*(DYNX(X_,0)-DYNX(DP_,3));
DYNX(W_,13) = DYNX(DP_,2)*DYNX(X_,1);
DYNX(W_,9) = DYNX(W_,12)+DYNX(W_,13);
 /* Linear system of equations to solve. */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 1);
SolveScalarLinearParametric(DYNX(DP_,7),"mass1.m", DYNX(W_,14)-DYNX(W_,9),
  "mass1.flange_b.f-( -mass1.flange_a.f)", DYNX(F_,1),"der(springDamper1.v_rel)");
 /* End of Equation Block */ 

DYNX(F_,3) = DYNX(W_,24)-DYNX(F_,1);
DYNX(F_,2) = DYNX(X_,3);
DYNX(F_,0) = DYNX(X_,1);

AcceptedSection1

AcceptedSection2
DYNX(W_,10) = DYNX(X_,0)+DYNX(DP_,0);
DYNX(W_,20) = DYNX(W_,10)+DYNX(DP_,8)/(double)(2);
DYNX(W_,15) = DYNX(W_,20)+DYNX(DP_,8)/(double)(2);
DYNX(W_,16) = DYNX(X_,2)+DYNX(W_,15);
DYNX(W_,21) = DYNX(W_,16)+DYNX(DP_,10)/(double)(2);
DYNX(W_,23) = DYNX(X_,3)+DYNX(X_,1);
DYNX(W_,11) = DYNX(W_,13)*DYNX(X_,1);
DYNX(W_,17) = DYNX(W_,19)*DYNX(X_,3);
DYNX(W_,22) = DYNX(W_,21)+DYNX(DP_,10)/(double)(2);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("fixed.s0", "Fixed offset position of housing [m]", 0, 0, \
0.0,0.0,0.0,0,560)
DeclareAlias2("fixed.flange.s", "Absolute position of flange [m]", "fixed.s0", 1,\
 7, 0, 4)
DeclareVariable("fixed.flange.f", "Cut force directed into flange [N]", 9, 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("springDamper1.stateSelect", "Priority to use s_rel and v_rel as states [:#(type=StateSelect)]",\
 0, 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("springDamper1.s_nominal", "Nominal value of s_rel (used for scaling) [m]",\
 1, 0.0001, 0.0,1E+100,0.0,0,513)
DeclareState("springDamper1.s_rel", "Relative distance (= flange_b.s - flange_a.s) [m]",\
 0, 0, 0.0,0.0,0.0001,0,560)
DeclareDerivative("springDamper1.der(s_rel)", "der(Relative distance (= flange_b.s - flange_a.s)) [m/s]",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareState("springDamper1.v_rel", "Relative velocity (= der(s_rel)) [m/s]", 1,\
 1, 0.0,0.0,0.0,0,560)
DeclareDerivative("springDamper1.der(v_rel)", "der(Relative velocity (= der(s_rel))) [m/s2]",\
 1, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("springDamper1.f", "Forces between flanges (= flange_b.f) [N]", \
"fixed.flange.f", 1, 5, 9, 0)
DeclareAlias2("springDamper1.flange_a.s", "Absolute position of flange [m]", \
"fixed.s0", 1, 7, 0, 4)
DeclareAlias2("springDamper1.flange_a.f", "Cut force directed into flange [N]", \
"fixed.flange.f", -1, 5, 9, 132)
DeclareVariable("springDamper1.flange_b.s", "Absolute position of flange [m]", 10,\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("springDamper1.flange_b.f", "Cut force directed into flange [N]", \
"fixed.flange.f", 1, 5, 9, 132)
DeclareParameter("springDamper1.c", "Spring constant [N/m]", 1, 3000, 0.0,1E+100,\
0.0,0,560)
DeclareParameter("springDamper1.d", "Damping constant [N.s/m]", 2, 30, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("springDamper1.s_rel0", "Unstretched spring length [m]", 3, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("springDamper1.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 2, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("springDamper1.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 11, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("springDamper1.f_c", "Spring force [N]", 12, 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("springDamper1.f_d", "Damping force [N]", 13, 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("springDamper2.stateSelect", "Priority to use s_rel and v_rel as states [:#(type=StateSelect)]",\
 3, 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("springDamper2.s_nominal", "Nominal value of s_rel (used for scaling) [m]",\
 4, 0.0001, 0.0,1E+100,0.0,0,513)
DeclareState("springDamper2.s_rel", "Relative distance (= flange_b.s - flange_a.s) [m]",\
 2, 0, 0.0,0.0,0.0001,0,560)
DeclareDerivative("springDamper2.der(s_rel)", "der(Relative distance (= flange_b.s - flange_a.s)) [m/s]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareState("springDamper2.v_rel", "Relative velocity (= der(s_rel)) [m/s]", 3,\
 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("springDamper2.der(v_rel)", "der(Relative velocity (= der(s_rel))) [m/s2]",\
 3, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("springDamper2.f", "Forces between flanges (= flange_b.f) [N]", 14,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("springDamper2.flange_a.s", "Absolute position of flange [m]", 15,\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("springDamper2.flange_a.f", "Cut force directed into flange [N]", \
"springDamper2.f", -1, 5, 14, 132)
DeclareVariable("springDamper2.flange_b.s", "Absolute position of flange [m]", 16,\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("springDamper2.flange_b.f", "Cut force directed into flange [N]", \
"springDamper2.f", 1, 5, 14, 132)
DeclareParameter("springDamper2.c", "Spring constant [N/m]", 4, 1000, 0.0,1E+100,\
0.0,0,560)
DeclareParameter("springDamper2.d", "Damping constant [N.s/m]", 5, 10, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("springDamper2.s_rel0", "Unstretched spring length [m]", 6, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("springDamper2.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 5, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("springDamper2.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 17, 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("springDamper2.f_c", "Spring force [N]", 18, 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("springDamper2.f_d", "Damping force [N]", 19, 0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("mass1.m", "Mass of the sliding mass [kg]", 7, 1, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("mass1.stateSelect", "Priority to use s and v as states [:#(type=StateSelect)]",\
 6, 3, 1.0,5.0,0.0,0,517)
DeclareVariable("mass1.s", "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2) [m]",\
 20, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("mass1.der(s)", "der(Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)) [m/s]",\
 "springDamper1.v_rel", 1, 1, 1, 0)
DeclareParameter("mass1.L", "Length of component, from left flange to right flange (= flange_b.s - flange_a.s) [m]",\
 8, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("mass1.flange_a.s", "Absolute position of flange [m]", \
"springDamper1.flange_b.s", 1, 5, 10, 4)
DeclareAlias2("mass1.flange_a.f", "Cut force directed into flange [N]", \
"fixed.flange.f", -1, 5, 9, 132)
DeclareAlias2("mass1.flange_b.s", "Absolute position of flange [m]", \
"springDamper2.flange_a.s", 1, 5, 15, 4)
DeclareAlias2("mass1.flange_b.f", "Cut force directed into flange [N]", \
"springDamper2.f", 1, 5, 14, 132)
DeclareAlias2("mass1.v", "Absolute velocity of component [m/s]", \
"springDamper1.v_rel", 1, 1, 1, 0)
DeclareAlias2("mass1.der(v)", "der(Absolute velocity of component) [m/s2]", \
"springDamper1.der(v_rel)", 1, 6, 1, 0)
DeclareAlias2("mass1.a", "Absolute acceleration of component [m/s2]", \
"springDamper1.der(v_rel)", 1, 6, 1, 0)
DeclareParameter("mass2.m", "Mass of the sliding mass [kg]", 9, 10, 0.0,1E+100,\
0.0,0,560)
DeclareVariable("mass2.stateSelect", "Priority to use s and v as states [:#(type=StateSelect)]",\
 7, 3, 1.0,5.0,0.0,0,517)
DeclareVariable("mass2.s", "Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2) [m]",\
 21, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("mass2.der(s)", "der(Absolute position of center of component (s = flange_a.s + L/2 = flange_b.s - L/2)) [m/s]",\
 "mass2.v", 1, 5, 23, 0)
DeclareParameter("mass2.L", "Length of component, from left flange to right flange (= flange_b.s - flange_a.s) [m]",\
 10, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("mass2.flange_a.s", "Absolute position of flange [m]", \
"springDamper2.flange_b.s", 1, 5, 16, 4)
DeclareAlias2("mass2.flange_a.f", "Cut force directed into flange [N]", \
"springDamper2.f", -1, 5, 14, 132)
DeclareVariable("mass2.flange_b.s", "Absolute position of flange [m]", 22, 0.0, \
0.0,0.0,0.0,0,520)
DeclareVariable("mass2.flange_b.f", "Cut force directed into flange [N]", 8, 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("mass2.v", "Absolute velocity of component [m/s]", 23, 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("mass2.der(v)", "der(Absolute velocity of component) [m/s2]", 24,\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("mass2.a", "Absolute acceleration of component [m/s2]", \
"mass2.der(v)", 1, 5, 24, 0)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(W_,24), 0, 0);
DoRemember_(DYNX(F_,1), 0, 1);
EndEqBlock
EndDataBlock
