#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Tutorial.Electrical.Examples.TestCircuit
 Dymola Version 2023x, 2022-10-07 translated this at Fri Mar 31 13:15:58 2023

   */

#include <matrixop.h>
#include "matrixop.c"
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    3
#define NX2_   0
#define NU_    0
#define NY_    0
#define NW_    26
#define NWP_   16
#define NP_    11
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 1703871907
#define NHash2_ -30044361
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    45
#define SizePre_ 0
#define SizeEq_ 2
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Tutorial.Electrical.Examples.TestCircuit";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/karlv/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[8]={2 , 2 , 1 , 2 , 1 , 3 , 0 , 0};
static int QJacobianGrp0[4]={1, 0, 1, 0};
static int QJacobianGrp1[4]={3, 3, 0, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[3]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{0,0}};
DYMOLA_STATIC double QJacobianCD_[4]={0  , 44 , 55 , 60};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
InitialSection

InitialSection
#if defined(DynSimStruct)
DYNX(W_,0) = false;
DYNX(W_,4) = false;
DYNX(W_,7) = 3;
DYNX(W_,10) = false;
DYNX(W_,3) = 0;
DYNX(W_,5) = 0.0;
DYNX(W_,8) = 0.0;
DYNX(W_,6) = 0.0;
DYNX(W_,9) = 0.0;
DYNX(W_,13) = 0.0;
DYNX(W_,15) = 0.0;
DYNX(W_,14) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(W_,1) = DYNX(DP_,1);
AssertModelica(1+DYNX(DP_,2)*(DYNX(W_,1)-DYNX(DP_,1)) >= 1E-15,"1+motor.resistor.alpha*(motor.resistor.T_heatPort-motor.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
DYNX(W_,11) = DYNX(DP_,9);
AssertModelica(1+DYNX(DP_,10)*(DYNX(W_,11)-DYNX(DP_,9)) >= 1E-15,
  "1+powerSupply.resistor.alpha*(powerSupply.resistor.T_heatPort-powerSupply.resistor.T_ref) >= 1E-15",
   "Temperature outside scope of model!");
BoundParameterConstantSection
DYNX(W_,2) = DYNX(DP_,0)*(1+DYNX(DP_,2)*(DYNX(W_,1)-DYNX(DP_,1)));
DYNX(W_,12) = DYNX(DP_,8)*(1+DYNX(DP_,10)*(DYNX(W_,11)-DYNX(DP_,9)));
BoundParameterSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,14) = 0.0;
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,16) = DYNX(W_,2)*DYNX(X_,0);
DYNX(W_,24) = DYNX(W_,12)*DYNX(X_,0);
DYNX(W_,21) = DYNX(DP_,7)-DYNX(W_,24);
DYNX(W_,17) = DYNX(W_,21)-DYNX(W_,16);
DYNX(W_,20) = DYNX(DP_,4)*DYNX(X_,2);
DYNX(W_,19) = DYNX(W_,17)-DYNX(W_,20);
 /* Linear system of equations to solve. */
DYNX(F_,0) = RememberSimple_(DYNX(F_,0), 0);
SolveScalarLinearParametric(DYNX(DP_,3),"motor.inductor.L", DYNX(W_,19),
  "motor.inductor.v", DYNX(F_,0),"der(motor.inductor.i)");
 /* End of Equation Block */ 

DYNX(W_,23) =  -DYNX(DP_,4)*DYNX(X_,0);
 /* Linear system of equations to solve. */
DYNX(F_,2) = RememberSimple_(DYNX(F_,2), 1);
SolveScalarLinearParametric(DYNX(DP_,6),"motor.inertia.J",  -DYNX(W_,23),
  "motor.inertia.flange_a.tau", DYNX(F_,2),"der(motor.inertia.w)");
 /* End of Equation Block */ 

DYNX(F_,1) = DYNX(X_,2);

AcceptedSection1

AcceptedSection2
DYNX(W_,22) = DYNX(X_,1)-DYNX(DP_,5);
DYNX(W_,18) = DYNX(W_,16)*DYNX(X_,0);
DYNX(W_,25) = DYNX(W_,24)*DYNX(X_,0);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("motor.resistor.R", "Resistance at temperature T_ref [Ohm]", 0,\
 1, 0.0,0.0,0.0,0,560)
DeclareParameter("motor.resistor.T_ref", "Reference temperature [K|degC]", 1, \
300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("motor.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 2, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("motor.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 16, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.resistor.p.v", "Potential at the pin [V]", "motor.plug.positive.v", 1,\
 5, 21, 4)
DeclareAlias2("motor.resistor.p.i", "Current flowing into the pin [A]", \
"motor.inductor.i", 1, 1, 0, 132)
DeclareVariable("motor.resistor.n.v", "Potential at the pin [V]", 17, 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("motor.resistor.n.i", "Current flowing into the pin [A]", \
"motor.inductor.i", -1, 1, 0, 132)
DeclareAlias2("motor.resistor.i", "Current flowing from pin p to pin n [A]", \
"motor.inductor.i", 1, 1, 0, 0)
DeclareVariable("motor.resistor.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 0, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("motor.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 1, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("motor.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 18, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.resistor.T_heatPort", "Temperature of heatPort [K|degC]", \
"motor.resistor.T", 1, 5, 1, 0)
DeclareVariable("motor.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 2, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("motor.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 19, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.inductor.p.v", "Potential at the pin [V]", "motor.resistor.n.v", 1,\
 5, 17, 4)
DeclareAlias2("motor.inductor.p.i", "Current flowing into the pin [A]", \
"motor.inductor.i", 1, 1, 0, 132)
DeclareVariable("motor.inductor.n.v", "Potential at the pin [V]", 20, 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("motor.inductor.n.i", "Current flowing into the pin [A]", \
"motor.inductor.i", -1, 1, 0, 132)
DeclareState("motor.inductor.i", "Current flowing from pin p to pin n [A]", 0, 0,\
 0.0,0.0,0.0,0,560)
DeclareDerivative("motor.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("motor.inductor.L", "Inductance [H]", 3, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("motor.plug.positive.v", "Potential at the pin [V]", 21, 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("motor.plug.positive.i", "Current flowing into the pin [A]", \
"motor.inductor.i", 1, 1, 0, 132)
DeclareVariable("motor.plug.negative.v", "Potential at the pin [V]", 3, 0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("motor.plug.negative.i", "Current flowing into the pin [A]", \
"motor.inductor.i", -1, 1, 0, 132)
DeclareVariable("motor.emf.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 4, false, 0.0,0.0,0.0,0,1539)
DeclareParameter("motor.emf.k", "Transformation coefficient [N.m/A]", 4, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("motor.emf.v", "Voltage drop between the two pins [V]", \
"motor.inductor.n.v", 1, 5, 20, 0)
DeclareAlias2("motor.emf.i", "Current flowing from positive to negative pin [A]",\
 "motor.inductor.i", 1, 1, 0, 0)
DeclareVariable("motor.emf.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 22, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.emf.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "motor.inertia.w", 1, 1, 2, 0)
DeclareAlias2("motor.emf.w", "Angular velocity of flange relative to support [rad/s]",\
 "motor.inertia.w", 1, 1, 2, 0)
DeclareVariable("motor.emf.tau", "Torque of flange [N.m]", 23, 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("motor.emf.tauElectrical", "Electrical torque [N.m]", \
"motor.emf.tau", -1, 5, 23, 0)
DeclareAlias2("motor.emf.p.v", "Potential at the pin [V]", "motor.inductor.n.v", 1,\
 5, 20, 4)
DeclareAlias2("motor.emf.p.i", "Current flowing into the pin [A]", \
"motor.inductor.i", 1, 1, 0, 132)
DeclareVariable("motor.emf.n.v", "Potential at the pin [V]", 5, 0.0, 0.0,0.0,0.0,\
0,521)
DeclareAlias2("motor.emf.n.i", "Current flowing into the pin [A]", \
"motor.inductor.i", -1, 1, 0, 132)
DeclareAlias2("motor.emf.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("motor.emf.flange.tau", "Cut torque in the flange [N.m]", \
"motor.emf.tau", 1, 5, 23, 132)
DeclareParameter("motor.emf.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 5, 0, 0.0,0.0,0.0,0,2608)
DeclareAlias2("motor.emf.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("motor.emf.fixed.flange.tau", "Cut torque in the flange [N.m]", \
"motor.emf.tau", 1, 5, 23, 1156)
DeclareAlias2("motor.emf.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "motor.emf.tau", -1, 5, 23, 1024)
DeclareAlias2("motor.emf.internalSupport.phi", "External support angle (= flange.phi) [rad|deg]",\
 "motor.emf.fixed.phi0", 1, 7, 5, 1024)
DeclareAlias2("motor.emf.internalSupport.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.emf.fixed.phi0", 1, 7, 5, 1028)
DeclareAlias2("motor.emf.internalSupport.flange.tau", "Cut torque in the flange [N.m]",\
 "motor.emf.tau", -1, 5, 23, 1156)
DeclareAlias2("motor.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("motor.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"motor.emf.tau", -1, 5, 23, 132)
DeclareAlias2("motor.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.inertia.phi", 1, 1, 1, 4)
DeclareVariable("motor.inertia.flange_b.tau", "Cut torque in the flange [N.m]", 6,\
 0.0, 0.0,0.0,0.0,0,777)
DeclareParameter("motor.inertia.J", "Moment of inertia [kg.m2]", 6, 1, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("motor.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 7, 3, 1.0,5.0,0.0,0,1541)
DeclareState("motor.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("motor.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareState("motor.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("motor.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("motor.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "motor.inertia.der(w)", 1, 6, 2, 0)
DeclareAlias2("motor.flange_b1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "motor.inertia.phi", 1, 1, 1, 4)
DeclareVariable("motor.flange_b1.tau", "Cut torque in the flange [N.m]", 8, 0.0,\
 0.0,0.0,0.0,0,777)
DeclareParameter("powerSupply.constantVoltage.V", "Value of constant voltage [V]",\
 7, 110, 0.0,0.0,0.0,0,560)
DeclareAlias2("powerSupply.constantVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "powerSupply.constantVoltage.V", 1, 7, 7, 0)
DeclareAlias2("powerSupply.constantVoltage.p.v", "Potential at the pin [V]", \
"powerSupply.constantVoltage.V", 1, 7, 7, 4)
DeclareAlias2("powerSupply.constantVoltage.p.i", "Current flowing into the pin [A]",\
 "motor.inductor.i", -1, 1, 0, 132)
DeclareVariable("powerSupply.constantVoltage.n.v", "Potential at the pin [V]", 9,\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("powerSupply.constantVoltage.n.i", "Current flowing into the pin [A]",\
 "motor.inductor.i", 1, 1, 0, 132)
DeclareAlias2("powerSupply.constantVoltage.i", "Current flowing from pin p to pin n [A]",\
 "motor.inductor.i", -1, 1, 0, 0)
DeclareParameter("powerSupply.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 8, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("powerSupply.resistor.T_ref", "Reference temperature [K|degC]",\
 9, 300.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("powerSupply.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 10, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("powerSupply.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 24, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("powerSupply.resistor.p.v", "Potential at the pin [V]", \
"powerSupply.constantVoltage.V", 1, 7, 7, 4)
DeclareAlias2("powerSupply.resistor.p.i", "Current flowing into the pin [A]", \
"motor.inductor.i", 1, 1, 0, 132)
DeclareAlias2("powerSupply.resistor.n.v", "Potential at the pin [V]", \
"motor.plug.positive.v", 1, 5, 21, 4)
DeclareAlias2("powerSupply.resistor.n.i", "Current flowing into the pin [A]", \
"motor.inductor.i", -1, 1, 0, 132)
DeclareAlias2("powerSupply.resistor.i", "Current flowing from pin p to pin n [A]",\
 "motor.inductor.i", 1, 1, 0, 0)
DeclareVariable("powerSupply.resistor.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 10, false, 0.0,0.0,0.0,0,1539)
DeclareVariable("powerSupply.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 11, 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("powerSupply.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 25, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("powerSupply.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 "powerSupply.resistor.T", 1, 5, 11, 0)
DeclareVariable("powerSupply.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 12, 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("powerSupply.ground.p.v", "Potential at the pin [V]", 13, 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("powerSupply.ground.p.i", "Current flowing into the pin [A]", 14,\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("powerSupply.plug.positive.v", "Potential at the pin [V]", \
"motor.plug.positive.v", 1, 5, 21, 4)
DeclareAlias2("powerSupply.plug.positive.i", "Current flowing into the pin [A]",\
 "motor.inductor.i", -1, 1, 0, 132)
DeclareVariable("powerSupply.plug.negative.v", "Potential at the pin [V]", 15, \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("powerSupply.plug.negative.i", "Current flowing into the pin [A]",\
 "motor.inductor.i", 1, 1, 0, 132)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
DoRemember_(DYNX(F_,0), 0.0, 0);
DoRemember_(DYNX(F_,2), 0.0, 1);
EndEqBlock
EndDataBlock
